#!/bin/bash
set -e
source ~/.bashrc # in case script is executed from a non-Bash shell

if [ -z "$TUFTSID" ] || [ -z "$TUFTSPASS" ]; then
    echo "TUFTSID and TUFTSPASS env variables need to be set for this script."
    exit 1
fi 

# getStatus: returns the server status on retrieving user data. Return codes:
#            1: server is ready 
#            0: server is not ready
#            -1: server error (as far as I can tell)
getStatus() {
    # GET request returns xml doc with a single <message> tag
    curl -s https://www.jumbocash.net/login-check.php?skey=${skey} |
    sed -n '2s/.*ge>\(.*\)<.*/\1/p'
}



echo "Retrieving data..."

cid="233" # Hard-coded variable on website
loginData="cid=${cid}&save=1&loginphrase=${TUFTSID}&password=${TUFTSPASS}"

# POST login data, then parse skey value from the html response.
skey="$(
    curl -s --data $loginData https://www.jumbocash.net/login.php |
    sed -n '3s/.*skey=\([0-9a-z][0-9a-z]*\).*/\1/p')"

# Necessary to GET this page for some reason. Script runs curl request 
# asynchronously, and ignores output.
curl -s "https://www.jumbocash.net/login.php?skey=${skey}&cid=${cid}&fullscreen=1&wason=" > /dev/null &

# Check every second if the server is ready. Fail on server error.
# TODO: limit number of attempts.
serverStatus=$(getStatus)
while [ "$serverStatus" != "1" ]; do
    if [ "$serverStatus" == "-1" ]; then
        >&2 echo "Server error."
        exit 1
    fi
    sleep 1 # pause for 1 second
    serverStatus=$(getStatus)
done;

# Handle flag arguments
for arg in "$@"; do
    case $arg in 
        -l) # open jumbocash.net page in browser already authenticated
            xdg-open "https://www.jumbocash.net/index.php?skey=${skey}&cid=${cid}&" &
            exit 0
            ;;
        -d) # open jumbocash.net deposit page
            xdg-open "https://www.jumbocash.net/payment.php?skey=${skey}&cid=${cid}&" &
            exit 0
            ;;
        *) 
            echo "Unrecognized arg: $arg"
            exit 1
            ;;
    esac
done

# Best solution I could find: retrieve final html page from server, then use 
# tee to pipe the final page into two separate commands. Tee also passes on its
# stdin to stdout, so this is just dumped to /dev/null. 
# The first command outputs the user's JumboCash balance to stdout (but not
# the same stdout instance as that of the tee command). 
# The second command parses and outputs the number of the user's remaining
#  mealswipes. 
curl -s "https://www.jumbocash.net/index.php?skey=${skey}&cid=${cid}&" |
tee >(sed -n 's/.*Balance: \([-0-9][0-9.]*\).*/Your Jumbocash balance is: \1./p') \
>(grep 'tablecolnum' | tail -1 |
sed -n 's/.*[^0-9]\([0-9][0-9]*\).*/You have \1 remaining meal swipes./p') >/dev/null
# tee command hangs when output is redirected (http://tinyurl.com/j696tgg);
# a short sleep call solves this
sleep .01 
# wait for the commands called from tee terminate, otherwise the command prompt
# appears before all of the output finishes
wait 
exit 0
